(define (list-sort compare lst)
  (define (merge left right)
    (let loop ((left left)
               (right right)
               (result '()))
      (cond
       ((and (null? left) (null? right))
        (reverse result))
       ((null? left)
        (loop left (cdr right) (cons (car right) result)))
       ((null? right)
        (loop (cdr left) right (cons (car left) result)))
       (else
        (let ((left1 (car left))
              (right1 (car right)))
          (if (compare left1 right1)
              (loop (cdr left) right (cons left1 result))
              (loop left (cdr right) (cons right1 result))))))))
  (define (pair-map! proc lst)
    ;; { a, b, c, d[, e] } -> f -> { f(a, b), f(c, d)[, e] }
    (unless (or (null? lst) (null? (cdr lst)))
      (let ((first (car lst))
            (second (car (cdr lst)))
            (rest (cdr (cdr lst))))
        (set-car! lst (proc first second))
        (set-cdr! lst rest)
        (pair-map! proc rest))))
  (if (or (null? lst) (null? (cdr lst)))
      lst
      (let ((sublists (map list lst)))
        (do ()
            ((null? (cdr sublists))
             (car sublists))
          (pair-map! merge sublists))))
)

